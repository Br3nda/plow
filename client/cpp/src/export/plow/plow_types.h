/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef plow_TYPES_H
#define plow_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "common_types.h"


namespace Plow {

struct JobState {
  enum type {
    INITIALIZE = 0,
    RUNNING = 1,
    FINISHED = 2
  };
};

extern const std::map<int, const char*> _JobState_VALUES_TO_NAMES;

struct TaskState {
  enum type {
    INITIALIZE = 0,
    WAITING = 1,
    RUNNING = 2,
    DEAD = 3,
    EATEN = 4,
    DEPEND = 5,
    SUCCEEDED = 6
  };
};

extern const std::map<int, const char*> _TaskState_VALUES_TO_NAMES;

typedef struct _PlowException__isset {
  _PlowException__isset() : what(false), why(false) {}
  bool what;
  bool why;
} _PlowException__isset;

class PlowException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  PlowException() : what(0), why() {
  }

  virtual ~PlowException() throw() {}

  int32_t what;
  std::string why;

  _PlowException__isset __isset;

  void __set_what(const int32_t val) {
    what = val;
  }

  void __set_why(const std::string& val) {
    why = val;
  }

  bool operator == (const PlowException & rhs) const
  {
    if (!(what == rhs.what))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const PlowException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlowException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PlowException &a, PlowException &b);

typedef struct _JobT__isset {
  _JobT__isset() : id(false), folderId(false), name(false), username(false), uid(false), state(false), paused(false), minCores(false), maxCores(false), startTime(false), stopTime(false), totalTaskCount(false), succeededTaskCount(false), runningTaskCount(false), deadTaskCount(false), eatenTaskCount(false), waitingTaskCount(false), dependTaskCount(false), runningCoreCount(false) {}
  bool id;
  bool folderId;
  bool name;
  bool username;
  bool uid;
  bool state;
  bool paused;
  bool minCores;
  bool maxCores;
  bool startTime;
  bool stopTime;
  bool totalTaskCount;
  bool succeededTaskCount;
  bool runningTaskCount;
  bool deadTaskCount;
  bool eatenTaskCount;
  bool waitingTaskCount;
  bool dependTaskCount;
  bool runningCoreCount;
} _JobT__isset;

class JobT {
 public:

  static const char* ascii_fingerprint; // = "B1F3F2A07631D476657CF9FDB15D76F0";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0xF3,0xF2,0xA0,0x76,0x31,0xD4,0x76,0x65,0x7C,0xF9,0xFD,0xB1,0x5D,0x76,0xF0};

  JobT() : id(), folderId(), name(), username(), uid(0), state((JobState::type)0), paused(0), minCores(0), maxCores(0), startTime(0), stopTime(0), totalTaskCount(0), succeededTaskCount(0), runningTaskCount(0), deadTaskCount(0), eatenTaskCount(0), waitingTaskCount(0), dependTaskCount(0), runningCoreCount(0) {
  }

  virtual ~JobT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid folderId;
  std::string name;
  std::string username;
  int32_t uid;
  JobState::type state;
  bool paused;
  int32_t minCores;
  int32_t maxCores;
   ::Plow::Timestamp startTime;
   ::Plow::Timestamp stopTime;
  int32_t totalTaskCount;
  int32_t succeededTaskCount;
  int32_t runningTaskCount;
  int32_t deadTaskCount;
  int32_t eatenTaskCount;
  int32_t waitingTaskCount;
  int32_t dependTaskCount;
  int32_t runningCoreCount;

  _JobT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_folderId(const  ::Plow::Guid& val) {
    folderId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  void __set_state(const JobState::type val) {
    state = val;
  }

  void __set_paused(const bool val) {
    paused = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_startTime(const  ::Plow::Timestamp val) {
    startTime = val;
  }

  void __set_stopTime(const  ::Plow::Timestamp val) {
    stopTime = val;
  }

  void __set_totalTaskCount(const int32_t val) {
    totalTaskCount = val;
  }

  void __set_succeededTaskCount(const int32_t val) {
    succeededTaskCount = val;
  }

  void __set_runningTaskCount(const int32_t val) {
    runningTaskCount = val;
  }

  void __set_deadTaskCount(const int32_t val) {
    deadTaskCount = val;
  }

  void __set_eatenTaskCount(const int32_t val) {
    eatenTaskCount = val;
  }

  void __set_waitingTaskCount(const int32_t val) {
    waitingTaskCount = val;
  }

  void __set_dependTaskCount(const int32_t val) {
    dependTaskCount = val;
  }

  void __set_runningCoreCount(const int32_t val) {
    runningCoreCount = val;
  }

  bool operator == (const JobT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(folderId == rhs.folderId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(paused == rhs.paused))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(totalTaskCount == rhs.totalTaskCount))
      return false;
    if (!(succeededTaskCount == rhs.succeededTaskCount))
      return false;
    if (!(runningTaskCount == rhs.runningTaskCount))
      return false;
    if (!(deadTaskCount == rhs.deadTaskCount))
      return false;
    if (!(eatenTaskCount == rhs.eatenTaskCount))
      return false;
    if (!(waitingTaskCount == rhs.waitingTaskCount))
      return false;
    if (!(dependTaskCount == rhs.dependTaskCount))
      return false;
    if (!(runningCoreCount == rhs.runningCoreCount))
      return false;
    return true;
  }
  bool operator != (const JobT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobT &a, JobT &b);

typedef struct _LayerT__isset {
  _LayerT__isset() : id(false), name(false), range(false), chunk(false), tags(false), minCores(false), maxCores(false), minRamMb(false), totalTaskCount(false), succeededTaskCount(false), runningTaskCount(false), deadTaskCount(false), eatenTaskCount(false), waitingTaskCount(false), dependTaskCount(false), runningCoreCount(false) {}
  bool id;
  bool name;
  bool range;
  bool chunk;
  bool tags;
  bool minCores;
  bool maxCores;
  bool minRamMb;
  bool totalTaskCount;
  bool succeededTaskCount;
  bool runningTaskCount;
  bool deadTaskCount;
  bool eatenTaskCount;
  bool waitingTaskCount;
  bool dependTaskCount;
  bool runningCoreCount;
} _LayerT__isset;

class LayerT {
 public:

  static const char* ascii_fingerprint; // = "8565B92EF1A69CF71EB8225F1D58A170";
  static const uint8_t binary_fingerprint[16]; // = {0x85,0x65,0xB9,0x2E,0xF1,0xA6,0x9C,0xF7,0x1E,0xB8,0x22,0x5F,0x1D,0x58,0xA1,0x70};

  LayerT() : id(), name(), range(), chunk(0), minCores(0), maxCores(0), minRamMb(0), totalTaskCount(0), succeededTaskCount(0), runningTaskCount(0), deadTaskCount(0), eatenTaskCount(0), waitingTaskCount(0), dependTaskCount(0), runningCoreCount(0) {
  }

  virtual ~LayerT() throw() {}

   ::Plow::Guid id;
  std::string name;
  std::string range;
  int32_t chunk;
  std::set<std::string>  tags;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRamMb;
  int32_t totalTaskCount;
  int32_t succeededTaskCount;
  int32_t runningTaskCount;
  int32_t deadTaskCount;
  int32_t eatenTaskCount;
  int32_t waitingTaskCount;
  int32_t dependTaskCount;
  int32_t runningCoreCount;

  _LayerT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_range(const std::string& val) {
    range = val;
  }

  void __set_chunk(const int32_t val) {
    chunk = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_minRamMb(const int32_t val) {
    minRamMb = val;
  }

  void __set_totalTaskCount(const int32_t val) {
    totalTaskCount = val;
  }

  void __set_succeededTaskCount(const int32_t val) {
    succeededTaskCount = val;
  }

  void __set_runningTaskCount(const int32_t val) {
    runningTaskCount = val;
  }

  void __set_deadTaskCount(const int32_t val) {
    deadTaskCount = val;
  }

  void __set_eatenTaskCount(const int32_t val) {
    eatenTaskCount = val;
  }

  void __set_waitingTaskCount(const int32_t val) {
    waitingTaskCount = val;
  }

  void __set_dependTaskCount(const int32_t val) {
    dependTaskCount = val;
  }

  void __set_runningCoreCount(const int32_t val) {
    runningCoreCount = val;
  }

  bool operator == (const LayerT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(minRamMb == rhs.minRamMb))
      return false;
    if (!(totalTaskCount == rhs.totalTaskCount))
      return false;
    if (!(succeededTaskCount == rhs.succeededTaskCount))
      return false;
    if (!(runningTaskCount == rhs.runningTaskCount))
      return false;
    if (!(deadTaskCount == rhs.deadTaskCount))
      return false;
    if (!(eatenTaskCount == rhs.eatenTaskCount))
      return false;
    if (!(waitingTaskCount == rhs.waitingTaskCount))
      return false;
    if (!(dependTaskCount == rhs.dependTaskCount))
      return false;
    if (!(runningCoreCount == rhs.runningCoreCount))
      return false;
    return true;
  }
  bool operator != (const LayerT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerT &a, LayerT &b);

typedef struct _TaskT__isset {
  _TaskT__isset() : id(false), name(false), number(false), dependCount(false), order(false), state(false), startTime(false), stopTime(false), lastNodeName(false), lastRss(false), lastCores(false), lastMaxRss(false) {}
  bool id;
  bool name;
  bool number;
  bool dependCount;
  bool order;
  bool state;
  bool startTime;
  bool stopTime;
  bool lastNodeName;
  bool lastRss;
  bool lastCores;
  bool lastMaxRss;
} _TaskT__isset;

class TaskT {
 public:

  static const char* ascii_fingerprint; // = "5511836BED2EB138652F3B893BCD9CCE";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x11,0x83,0x6B,0xED,0x2E,0xB1,0x38,0x65,0x2F,0x3B,0x89,0x3B,0xCD,0x9C,0xCE};

  TaskT() : id(), name(), number(0), dependCount(0), order(0), state((TaskState::type)0), startTime(0), stopTime(0), lastNodeName(), lastRss(0), lastCores(0), lastMaxRss(0) {
  }

  virtual ~TaskT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t number;
  int32_t dependCount;
  int32_t order;
  TaskState::type state;
   ::Plow::Timestamp startTime;
   ::Plow::Timestamp stopTime;
  std::string lastNodeName;
  int32_t lastRss;
  int32_t lastCores;
  int32_t lastMaxRss;

  _TaskT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_number(const int32_t val) {
    number = val;
  }

  void __set_dependCount(const int32_t val) {
    dependCount = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_state(const TaskState::type val) {
    state = val;
  }

  void __set_startTime(const  ::Plow::Timestamp val) {
    startTime = val;
  }

  void __set_stopTime(const  ::Plow::Timestamp val) {
    stopTime = val;
  }

  void __set_lastNodeName(const std::string& val) {
    lastNodeName = val;
  }

  void __set_lastRss(const int32_t val) {
    lastRss = val;
  }

  void __set_lastCores(const int32_t val) {
    lastCores = val;
  }

  void __set_lastMaxRss(const int32_t val) {
    lastMaxRss = val;
  }

  bool operator == (const TaskT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(number == rhs.number))
      return false;
    if (!(dependCount == rhs.dependCount))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(lastNodeName == rhs.lastNodeName))
      return false;
    if (!(lastRss == rhs.lastRss))
      return false;
    if (!(lastCores == rhs.lastCores))
      return false;
    if (!(lastMaxRss == rhs.lastMaxRss))
      return false;
    return true;
  }
  bool operator != (const TaskT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskT &a, TaskT &b);

typedef struct _LayerBp__isset {
  _LayerBp__isset() : name(false), command(false), tags(false), range(false), chunk(false), minCores(false), maxCores(false), minRamMb(false) {}
  bool name;
  bool command;
  bool tags;
  bool range;
  bool chunk;
  bool minCores;
  bool maxCores;
  bool minRamMb;
} _LayerBp__isset;

class LayerBp {
 public:

  static const char* ascii_fingerprint; // = "360CE99EC00D93465A047B4C9377F805";
  static const uint8_t binary_fingerprint[16]; // = {0x36,0x0C,0xE9,0x9E,0xC0,0x0D,0x93,0x46,0x5A,0x04,0x7B,0x4C,0x93,0x77,0xF8,0x05};

  LayerBp() : name(), range(), chunk(0), minCores(0), maxCores(0), minRamMb(0) {
  }

  virtual ~LayerBp() throw() {}

  std::string name;
  std::vector<std::string>  command;
  std::set<std::string>  tags;
  std::string range;
  int32_t chunk;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRamMb;

  _LayerBp__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_command(const std::vector<std::string> & val) {
    command = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_range(const std::string& val) {
    range = val;
  }

  void __set_chunk(const int32_t val) {
    chunk = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_minRamMb(const int32_t val) {
    minRamMb = val;
  }

  bool operator == (const LayerBp & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(command == rhs.command))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(minRamMb == rhs.minRamMb))
      return false;
    return true;
  }
  bool operator != (const LayerBp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerBp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerBp &a, LayerBp &b);

typedef struct _JobBp__isset {
  _JobBp__isset() : name(false), project(false), paused(false), username(false), uid(false) {}
  bool name;
  bool project;
  bool paused;
  bool username;
  bool uid;
} _JobBp__isset;

class JobBp {
 public:

  static const char* ascii_fingerprint; // = "B9078E05E4A0B18CED0894B22B3054D4";
  static const uint8_t binary_fingerprint[16]; // = {0xB9,0x07,0x8E,0x05,0xE4,0xA0,0xB1,0x8C,0xED,0x08,0x94,0xB2,0x2B,0x30,0x54,0xD4};

  JobBp() : name(), project(), paused(0), username(), uid(0) {
  }

  virtual ~JobBp() throw() {}

  std::string name;
  std::string project;
  bool paused;
  std::string username;
  int32_t uid;

  _JobBp__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_project(const std::string& val) {
    project = val;
  }

  void __set_paused(const bool val) {
    paused = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  bool operator == (const JobBp & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(project == rhs.project))
      return false;
    if (!(paused == rhs.paused))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(uid == rhs.uid))
      return false;
    return true;
  }
  bool operator != (const JobBp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobBp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobBp &a, JobBp &b);

typedef struct _Blueprint__isset {
  _Blueprint__isset() : job(false), layers(false) {}
  bool job;
  bool layers;
} _Blueprint__isset;

class Blueprint {
 public:

  static const char* ascii_fingerprint; // = "47C1B66935AA65EF759ABB2C77CE805D";
  static const uint8_t binary_fingerprint[16]; // = {0x47,0xC1,0xB6,0x69,0x35,0xAA,0x65,0xEF,0x75,0x9A,0xBB,0x2C,0x77,0xCE,0x80,0x5D};

  Blueprint() {
  }

  virtual ~Blueprint() throw() {}

  JobBp job;
  std::vector<LayerBp>  layers;

  _Blueprint__isset __isset;

  void __set_job(const JobBp& val) {
    job = val;
  }

  void __set_layers(const std::vector<LayerBp> & val) {
    layers = val;
  }

  bool operator == (const Blueprint & rhs) const
  {
    if (!(job == rhs.job))
      return false;
    if (!(layers == rhs.layers))
      return false;
    return true;
  }
  bool operator != (const Blueprint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Blueprint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Blueprint &a, Blueprint &b);

typedef struct _JobFilter__isset {
  _JobFilter__isset() : project(false), user(false), regex(false), states(false) {}
  bool project;
  bool user;
  bool regex;
  bool states;
} _JobFilter__isset;

class JobFilter {
 public:

  static const char* ascii_fingerprint; // = "B163C1438755B7D30E822096C0C13D63";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x63,0xC1,0x43,0x87,0x55,0xB7,0xD3,0x0E,0x82,0x20,0x96,0xC0,0xC1,0x3D,0x63};

  JobFilter() : regex() {
  }

  virtual ~JobFilter() throw() {}

  std::vector<std::string>  project;
  std::vector<std::string>  user;
  std::string regex;
  std::vector<JobState::type>  states;

  _JobFilter__isset __isset;

  void __set_project(const std::vector<std::string> & val) {
    project = val;
    __isset.project = true;
  }

  void __set_user(const std::vector<std::string> & val) {
    user = val;
    __isset.user = true;
  }

  void __set_regex(const std::string& val) {
    regex = val;
    __isset.regex = true;
  }

  void __set_states(const std::vector<JobState::type> & val) {
    states = val;
    __isset.states = true;
  }

  bool operator == (const JobFilter & rhs) const
  {
    if (__isset.project != rhs.__isset.project)
      return false;
    else if (__isset.project && !(project == rhs.project))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.regex != rhs.__isset.regex)
      return false;
    else if (__isset.regex && !(regex == rhs.regex))
      return false;
    if (__isset.states != rhs.__isset.states)
      return false;
    else if (__isset.states && !(states == rhs.states))
      return false;
    return true;
  }
  bool operator != (const JobFilter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobFilter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobFilter &a, JobFilter &b);

} // namespace

#endif
